[{"title":"QEMU CXL 模拟环境搭建","url":"/2026/01/31/QEMU-CXL-%E6%A8%A1%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","content":"使用QEMU模拟CXL设备本文只介绍环境搭建过程,CXL设备的使用,之后再说\n\n总览研发的目标平台是CXL3.0,目前物理设备尚未生产出来,使用QEMU来模拟CXL设备\nLinux内核对于CXL的支持情况\n\n\n\n功能\n最低内核版本\n说明\n\n\n\nCXL 总线与 Type 3 内存设备基本支持\nv5.17\n初步引入 cxl_core 子系统，但功能有限\n\n\nCXL 内存作为 System RAM 注册\nv6.3\n可通过 add_memory() 将 CXL 内存加入 buddy allocator\n\n\n完整 DAX 支持（&#x2F;dev&#x2F;daxX.Y）\nv6.4–6.6\n需配合 cxl_pmem 和 device-dax\n\n\nACPI CDAT&#x2F;HMAT 解析（用于 QEMU 模拟）\nv6.6+\nQEMU 通过 ACPI 表描述 CXL 拓扑\n\n\nCXL 2.0&#x2F;3.0 交换机与多端口模拟支持\nv6.8+\n更好支持 QEMU 的 CXL 拓扑建模\n\n\n稳定性和调试工具（cxl-cli, sysfs 接口）\nv6.9+\n用户态工具链成熟\n\n\nQEMU对于CXL的支持情况\n\n\n\nQEMU 版本\n发布时间\nCXL 支持亮点\n\n\n\n7.2\n2022 年底\n初步支持 CXL 2.0 Type 3 内存设备（基础仿真）\n\n\n8.0\n2023 年中\n重大扩展：HDM 解码器、CXL 交换机、内存交织\n\n\n8.1–8.2\n2023–2024\n稳定性提升，ACPI 表支持（CDAT&#x2F;HMAT）\n\n\n9.0\n2024 年中\n支持 Type 1&#x2F;2 设备、MMIO 缓存、NUMA 拓扑\n\n\n9.1\n2024 年底\nCXL 3.0 Type 3 设备、动态容量设备（DCD）初步支持\n\n\n10.0–10.1\n2025 年\nCXL 3.0 全面支持、热插拔、嵌套虚拟化、多层交换\n\n\n\n选用Linux Kernel 6.11 和 QEMU 10.1.3\n\n依赖安装sudo apt-get install libglib2.0-dev libgcrypt20-dev zlib1g-dev \\    autoconf automake libtool bison flex libpixman-1-dev bc  \\    make ninja-build libncurses-dev libelf-dev libssl-dev debootstrap \\    libcap-ng-dev libattr1-dev libslirp-dev libslirp0sudo apt-get install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bisonpip3 install tomli\n\nQEMU编译安装QEMU环境好配,设置目标平台为x86_64,并且启用debug模式,方便断点调试Kernel\n\n# 完整拉取git clone -b v10.1.3 https://github.com/qemu/qemu.git# 只拉取最浅层(推荐,我们只需要编译源码)git clone --depth 1 --single-branch --no-tags -b v10.1.3 https://github.com/qemu/qemu.git# 编译安装cd qemu./configure --target-list=x86_64-softmmu --enable-debugmake -j$(nproc)# 修改~/.bashrc或~/.zshrcalias qemu=&#x27;~/tool/qemu/build/qemu-system-x86_64&#x27; # 设置为你自己的编译路径\n\nLinux KernelKernel的配置项较为复杂,本来想直接使用CXL-Emulator-QEMU这个仓库中的.config文件,但是作者太粗糙了,打包了所有的驱动,众所周知,驱动是内核最大的一坨屎山,编译时间巨长,只能自己配置。\n推荐使用menuconfig界面,启用PCIE,CXL,DAX三个选项\ngit clone --depth 1 --single-branch --no-tags -b v6.11 https://github.com/torvalds/linux.git# 生成配置项make menuconfig # 启用完整的 PCIE支持 CXL支持 DAX支持\n\n如果想直接修改.config,先make localmodconfig根据主机信息来配置驱动和模块,然后复制下面的选项,或者使用scripts/config --enable 选项名的形式逐个添加\n&lt;!-- 修改.config文件 --&gt;CONFIG_PCIEAER_CXL=yCONFIG_CXL_BUS=yCONFIG_CXL_PCI=yCONFIG_CXL_MEM_RAW_COMMANDS=yCONFIG_CXL_ACPI=yCONFIG_CXL_PMEM=yCONFIG_CXL_MEM=yCONFIG_CXL_PORT=yCONFIG_CXL_SUSPEND=yCONFIG_CXL_REGION=yCONFIG_CXL_REGION_INVALIDATION_TEST=yCONFIG_DWC_PCIE_PMU=yCONFIG_CXL_PMU=yCONFIG_DAX=yCONFIG_DEV_DAX=yCONFIG_DEV_DAX_PMEM=yCONFIG_DEV_DAX_HMEM=yCONFIG_DEV_DAX_CXL=yCONFIG_DEV_DAX_HMEM_DEVICES=yCONFIG_DEV_DAX_KMEM=yCONFIG_NVMEM=yCONFIG_NVMEM_SYSFS=y\n\n编译安装\nmake -j$(nproc)ls arch/x86_64/boot/bzImage -lh # 检测是否编译成果sudo make modules_install\n\nQEMU启动在本章节一共需要使用三个目录,QEMU_PATH,KERNEL_PATH,DISK_PATH\n为客户机创建根文件系统:\ncd $(QEMU_PATH)# 创建磁盘镜像文件./build/qemu-img create qemu-cxl-img 40G# 格式化文件系统sudo mkfs.ext4 qemu-cxl-img# 创建挂载目录mkdir ~/qemu-cxl-mnt# 挂载磁盘镜像sudo mount -o loop ./qemu-cxl-img ~/qemu-cxl-mnt# 安装ubuntu发行版sudo debootstrap --arch amd64 jammy ~/qemu-cxl-mnt\n\n设置虚拟机和主机互通:修改用户名为你的用户名\necho &quot;#! /bin/bashmount -t 9p -o trans=virtio homeshare /home/zmymount -t 9p -o trans=virtio modshare /lib/modules&quot; &gt; ./rc.localchmod a+x ./rc.localsudo mv ./rc.local ~/qemu-cxl-mnt/etc/sudo mkdir -p ~/qemu-cxl-mnt/home/zmysudo mkdir -p ~/qemu-cxl-mnt/lib/modules/\n\n设置网络:\nsudo mkdir -p ~/qemu-cxl-mnt/etc/netplanvim -p ~/qemu-cxl-mnt/etc/netplan/config.yamlll ~/qemu-cxl-mnt/etc/netplan/config.yaml\n其中config.yaml文件内容如下:\nnetwork:    version: 2    renderer: networkd    ethernets:        enp0s2:            dhcp4: true\n\n设置虚拟机用户密码: 之后就使用root用户登录虚拟机镜像\nsudo chroot ~/qemu-cxl-mnt passwdexit\n\n启动虚拟机,并配置512MiB的持久化CXL内存: start_qemu-pmem.sh\n#!/bin/bash# 替换路径为你的路径QEMU_BIN=&quot;$HOME/tool/qemu/build/qemu-system-x86_64&quot;KERNEL_IMG=&quot;$HOME/work/mempool/linux/arch/x86_64/boot/bzImage&quot;DISK_IMG=&quot;$HOME/tool/qemu/qemu-cxl-img&quot;$QEMU_BIN \\    -s \\    -kernel $KERNEL_IMG \\    -append &quot;root=/dev/sda rw console=ttyS0,115200 ignore_loglevel nokaslr \\             cxl_acpi.dyndbg=+fplm cxl_pci.dyndbg=+fplm cxl_core.dyndbg=+fplm \\             cxl_mem.dyndbg=+fplm cxl_pmem.dyndbg=+fplm cxl_port.dyndbg=+fplm \\             cxl_region.dyndbg=+fplm cxl_test.dyndbg=+fplm cxl_mock.dyndbg=+fplm \\             cxl_mock_mem.dyndbg=+fplm dax.dyndbg=+fplm dax_cxl.dyndbg=+fplm \\             device_dax.dyndbg=+fplm&quot; \\    -smp 1 \\    -accel kvm \\    -serial mon:stdio \\    -nographic \\    -qmp tcp:localhost:4444,server,wait=off \\    -netdev user,id=network0,hostfwd=tcp::2024-:22 \\    -device e1000,netdev=network0 \\    -monitor telnet:127.0.0.1:12345,server,nowait \\    -drive file=$DISK_IMG,index=0,media=disk,format=raw \\    -machine q35,cxl=on -m 8G,maxmem=32G,slots=8 \\    -virtfs local,path=/lib/modules,mount_tag=modshare,security_model=mapped \\    -virtfs local,path=/home/zmy,mount_tag=homeshare,security_model=mapped # 替换用户名为你设置的用户名 \\     -object memory-backend-file,id=cxl-mem1,share=on,mem-path=/tmp/cxltest.raw,size=512M \\    -object memory-backend-file,id=cxl-lsa1,share=on,mem-path=/tmp/lsa.raw,size=512M \\    -device pxb-cxl,bus_nr=12,bus=pcie.0,id=cxl.1 \\    -device cxl-rp,port=0,bus=cxl.1,id=root_port13,chassis=0,slot=2 \\    -device cxl-type3,bus=root_port13,memdev=cxl-mem1,lsa=cxl-lsa1,id=cxl-pmem0 \\    -M cxl-fmw.0.targets.0=cxl.1,cxl-fmw.0.size=4G,cxl-fmw.0.interleave-granularity=8k\n\n\n启动虚拟机,并配置CXL动态容量设备: 2个区域,每个2GiB\n#!/bin/bashQEMU_BIN=&quot;$HOME/tool/qemu/build/qemu-system-x86_64&quot;KERNEL_IMG=&quot;$HOME/work/mempool/linux/arch/x86_64/boot/bzImage&quot;DISK_IMG=&quot;$HOME/tool/qemu/qemu-cxl-img&quot;$QEMU_BIN \\    -s \\    -kernel $KERNEL_IMG \\    -append &quot;root=/dev/sda rw console=ttyS0,115200 ignore_loglevel nokaslr \\             cxl_acpi.dyndbg=+fplm cxl_pci.dyndbg=+fplm cxl_core.dyndbg=+fplm \\             cxl_mem.dyndbg=+fplm cxl_pmem.dyndbg=+fplm cxl_port.dyndbg=+fplm \\             cxl_region.dyndbg=+fplm cxl_test.dyndbg=+fplm cxl_mock.dyndbg=+fplm \\             cxl_mock_mem.dyndbg=+fplm dax.dyndbg=+fplm dax_cxl.dyndbg=+fplm \\             device_dax.dyndbg=+fplm&quot; \\    -smp 1 \\    -accel kvm \\    -serial mon:stdio \\    -nographic \\    -qmp tcp:localhost:4444,server,wait=off \\    -netdev user,id=network0,hostfwd=tcp::2024-:22 \\    -device e1000,netdev=network0 \\    -monitor telnet:127.0.0.1:12345,server,nowait \\    -drive file=$DISK_IMG,index=0,media=disk,format=raw \\    -machine q35,cxl=on -m 8G,maxmem=32G,slots=8 \\    -virtfs local,path=/lib/modules,mount_tag=modshare,security_model=mapped \\    -virtfs local,path=/home/zmy,mount_tag=homeshare,security_model=mapped #替换用户名为你设置的用户名  \\    -device pxb-cxl,bus_nr=12,bus=pcie.0,id=cxl.1 \\    -device cxl-rp,port=13,bus=cxl.1,id=root_port13,chassis=0,slot=2 \\    -object memory-backend-file,id=dhmem0,share=on,mem-path=/tmp/dhmem0.raw,size=4G \\    -object memory-backend-file,id=lsa0,share=on,mem-path=/tmp/lsa0.raw,size=512M \\    -device cxl-type3,bus=root_port13,volatile-dc-memdev=dhmem0,num-dc-regions=2,id=cxl-memdev0 \\    -M cxl-fmw.0.targets.0=cxl.1,cxl-fmw.0.size=4G,cxl-fmw.0.interleave-granularity=8K\n\n启动虚拟机网络:\nip link set dev enp0s2 updhclient enp0s2\n\n查询CXL设备:\napt install pciutilslspcilspci | grep CXLlspci -vvvlspci -vvv -s 0d:00.0\n\n小结按照上述流程,可以成功编译QEMU和Kernel,并使用虚拟机模拟CXL设备,美中不足的是参考文献的作者使用的是2.X的CXL设备,如何启动3.X的设备之后再探索\n参考文献\nCXL-Emulator-QEMU\n\n","categories":["Linux Kernel"],"tags":["QEMU","CXL","Linux Kernel"]},{"title":"序章","url":"/2026/01/29/%E5%BA%8F%E7%AB%A0/","content":"人生的前二十年我对做笔记不屑一顾,大三接连打了DB&amp;OceanBase比赛,赛后很久又需要用到数据库底层知识,才发现基础知识与细节忘得差不多,面对密密麻麻的收藏夹和链接感到手足无措,此后才开始逐步探索建立个人知识体系。笔记确实是必要的,人脑也可类比计算机,内存是稀少的,只能存少量近期热数据,磁盘容量也不大,更多的是建立知识索引,知道有什么,是什么,在哪里,笔记就是知识和体验的载体。看了很多代码,看了很多Paper,读了很多文章,不进行推理输出,这些参数终究没办法被持久化,只会是进进出出一无所获。在这清净的一方天地,写一些技术文章,代码剖析,论文解读,读书笔记,以及一些些思考,仅此而已。\n","categories":["杂谈"]}]