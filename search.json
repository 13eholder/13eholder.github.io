[{"title":"QEMU CXL 模拟环境搭建","url":"/2026/01/31/QEMU-CXL-%E6%A8%A1%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","content":"使用QEMU模拟CXL设备本文只介绍环境搭建过程,CXL设备的使用,之后再说\n\n总览研发的目标平台是CXL3.0,目前物理设备尚未生产出来,使用QEMU来模拟CXL设备\nLinux内核对于CXL的支持情况\n\n\n\n功能\n最低内核版本\n说明\n\n\n\nCXL 总线与 Type 3 内存设备基本支持\nv5.17\n初步引入 cxl_core 子系统，但功能有限\n\n\nCXL 内存作为 System RAM 注册\nv6.3\n可通过 add_memory() 将 CXL 内存加入 buddy allocator\n\n\n完整 DAX 支持（&#x2F;dev&#x2F;daxX.Y）\nv6.4–6.6\n需配合 cxl_pmem 和 device-dax\n\n\nACPI CDAT&#x2F;HMAT 解析（用于 QEMU 模拟）\nv6.6+\nQEMU 通过 ACPI 表描述 CXL 拓扑\n\n\nCXL 2.0&#x2F;3.0 交换机与多端口模拟支持\nv6.8+\n更好支持 QEMU 的 CXL 拓扑建模\n\n\n稳定性和调试工具（cxl-cli, sysfs 接口）\nv6.9+\n用户态工具链成熟\n\n\nQEMU对于CXL的支持情况\n\n\n\nQEMU 版本\n发布时间\nCXL 支持亮点\n\n\n\n7.2\n2022 年底\n初步支持 CXL 2.0 Type 3 内存设备（基础仿真）\n\n\n8.0\n2023 年中\n重大扩展：HDM 解码器、CXL 交换机、内存交织\n\n\n8.1–8.2\n2023–2024\n稳定性提升，ACPI 表支持（CDAT&#x2F;HMAT）\n\n\n9.0\n2024 年中\n支持 Type 1&#x2F;2 设备、MMIO 缓存、NUMA 拓扑\n\n\n9.1\n2024 年底\nCXL 3.0 Type 3 设备、动态容量设备（DCD）初步支持\n\n\n10.0–10.1\n2025 年\nCXL 3.0 全面支持、热插拔、嵌套虚拟化、多层交换\n\n\n\n选用Linux Kernel 6.11 和 QEMU 10.1.3\n\n依赖安装sudo apt-get install libglib2.0-dev libgcrypt20-dev zlib1g-dev \\    autoconf automake libtool bison flex libpixman-1-dev bc  \\    make ninja-build libncurses-dev libelf-dev libssl-dev debootstrap \\    libcap-ng-dev libattr1-dev libslirp-dev libslirp0sudo apt-get install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bisonpip3 install tomli\n\nQEMU编译安装QEMU环境好配,设置目标平台为x86_64,并且启用debug模式,方便断点调试Kernel\n\n# 完整拉取git clone -b v10.1.3 https://github.com/qemu/qemu.git# 只拉取最浅层(推荐,我们只需要编译源码)git clone --depth 1 --single-branch --no-tags -b v10.1.3 https://github.com/qemu/qemu.git# 编译安装cd qemu./configure --target-list=x86_64-softmmu --enable-debugmake -j$(nproc)# 修改~/.bashrc或~/.zshrcalias qemu=&#x27;~/tool/qemu/build/qemu-system-x86_64&#x27; # 设置为你自己的编译路径\n\nLinux KernelKernel的配置项较为复杂,本来想直接使用CXL-Emulator-QEMU这个仓库中的.config文件,但是作者太粗糙了,打包了所有的驱动,众所周知,驱动是内核最大的一坨屎山,编译时间巨长,只能自己配置。\n推荐使用menuconfig界面,启用PCIE,CXL,DAX三个选项\ngit clone --depth 1 --single-branch --no-tags -b v6.11 https://github.com/torvalds/linux.git# 生成配置项make menuconfig # 启用完整的 PCIE支持 CXL支持 DAX支持\n\n如果想直接修改.config,先make localmodconfig根据主机信息来配置驱动和模块,然后复制下面的选项,或者使用scripts/config --enable 选项名的形式逐个添加\n&lt;!-- 修改.config文件 --&gt;CONFIG_PCIEAER_CXL=yCONFIG_CXL_BUS=yCONFIG_CXL_PCI=yCONFIG_CXL_MEM_RAW_COMMANDS=yCONFIG_CXL_ACPI=yCONFIG_CXL_PMEM=yCONFIG_CXL_MEM=yCONFIG_CXL_PORT=yCONFIG_CXL_SUSPEND=yCONFIG_CXL_REGION=yCONFIG_CXL_REGION_INVALIDATION_TEST=yCONFIG_DWC_PCIE_PMU=yCONFIG_CXL_PMU=yCONFIG_DAX=yCONFIG_DEV_DAX=yCONFIG_DEV_DAX_PMEM=yCONFIG_DEV_DAX_HMEM=yCONFIG_DEV_DAX_CXL=yCONFIG_DEV_DAX_HMEM_DEVICES=yCONFIG_DEV_DAX_KMEM=yCONFIG_NVMEM=yCONFIG_NVMEM_SYSFS=y\n\n编译安装\nmake -j$(nproc)ls arch/x86_64/boot/bzImage -lh # 检测是否编译成果sudo make modules_install\n\nQEMU启动在本章节一共需要使用三个目录,QEMU_PATH,KERNEL_PATH,DISK_PATH\n为客户机创建根文件系统:\ncd $(QEMU_PATH)# 创建磁盘镜像文件./build/qemu-img create qemu-cxl-img 40G# 格式化文件系统sudo mkfs.ext4 qemu-cxl-img# 创建挂载目录mkdir ~/qemu-cxl-mnt# 挂载磁盘镜像sudo mount -o loop ./qemu-cxl-img ~/qemu-cxl-mnt# 安装ubuntu发行版sudo debootstrap --arch amd64 noble ~/qemu-cxl-mnt\n\n设置虚拟机和主机互通:修改用户名为你的用户名\necho &quot;#! /bin/bashmount -t 9p -o trans=virtio homeshare /home/zmymount -t 9p -o trans=virtio modshare /lib/modules&quot; &gt; ./rc.localchmod a+x ./rc.localsudo mv ./rc.local ~/qemu-cxl-mnt/etc/sudo mkdir -p ~/qemu-cxl-mnt/home/zmysudo mkdir -p ~/qemu-cxl-mnt/lib/modules/\n\n设置网络:\nsudo mkdir -p ~/qemu-cxl-mnt/etc/netplanvim -p ~/qemu-cxl-mnt/etc/netplan/config.yamlll ~/qemu-cxl-mnt/etc/netplan/config.yaml\n其中config.yaml文件内容如下:\nnetwork:    version: 2    renderer: networkd    ethernets:        enp0s2:            dhcp4: true\n\n设置虚拟机用户密码: 之后就使用root用户登录虚拟机镜像\nsudo chroot ~/qemu-cxl-mnt passwdexit\n\n启动虚拟机,并配置512MiB的持久化CXL内存: start_qemu-pmem.sh\n#!/bin/bash# 替换路径为你的路径QEMU_BIN=&quot;$HOME/tool/qemu/build/qemu-system-x86_64&quot;KERNEL_IMG=&quot;$HOME/work/mempool/linux/arch/x86_64/boot/bzImage&quot;DISK_IMG=&quot;$HOME/tool/qemu/qemu-cxl-img&quot;$QEMU_BIN \\    -s \\    -kernel $KERNEL_IMG \\    -append &quot;root=/dev/sda rw console=ttyS0,115200 ignore_loglevel nokaslr \\             cxl_acpi.dyndbg=+fplm cxl_pci.dyndbg=+fplm cxl_core.dyndbg=+fplm \\             cxl_mem.dyndbg=+fplm cxl_pmem.dyndbg=+fplm cxl_port.dyndbg=+fplm \\             cxl_region.dyndbg=+fplm cxl_test.dyndbg=+fplm cxl_mock.dyndbg=+fplm \\             cxl_mock_mem.dyndbg=+fplm dax.dyndbg=+fplm dax_cxl.dyndbg=+fplm \\             device_dax.dyndbg=+fplm&quot; \\    -smp 1 \\    -accel kvm \\    -serial mon:stdio \\    -nographic \\    -qmp tcp:localhost:4444,server,wait=off \\    -netdev user,id=network0,hostfwd=tcp::2024-:22 \\    -device e1000,netdev=network0 \\    -monitor telnet:127.0.0.1:12345,server,nowait \\    -drive file=$DISK_IMG,index=0,media=disk,format=raw \\    -machine q35,cxl=on -m 8G,maxmem=32G,slots=8 \\    -virtfs local,path=/lib/modules,mount_tag=modshare,security_model=mapped \\    -virtfs local,path=/home/zmy,mount_tag=homeshare,security_model=mapped # 替换用户名为你设置的用户名 \\     -object memory-backend-file,id=cxl-mem1,share=on,mem-path=/tmp/cxltest.raw,size=512M \\    -object memory-backend-file,id=cxl-lsa1,share=on,mem-path=/tmp/lsa.raw,size=512M \\    -device pxb-cxl,bus_nr=12,bus=pcie.0,id=cxl.1 \\    -device cxl-rp,port=0,bus=cxl.1,id=root_port13,chassis=0,slot=2 \\    -device cxl-type3,bus=root_port13,memdev=cxl-mem1,lsa=cxl-lsa1,id=cxl-pmem0 \\    -M cxl-fmw.0.targets.0=cxl.1,cxl-fmw.0.size=4G,cxl-fmw.0.interleave-granularity=8k\n\n\n启动虚拟机,并配置CXL动态容量设备: 2个区域,每个2GiB\n#!/bin/bashQEMU_BIN=&quot;$HOME/tool/qemu/build/qemu-system-x86_64&quot;KERNEL_IMG=&quot;$HOME/work/mempool/linux/arch/x86_64/boot/bzImage&quot;DISK_IMG=&quot;$HOME/tool/qemu/qemu-cxl-img&quot;$QEMU_BIN \\    -s \\    -kernel $KERNEL_IMG \\    -append &quot;root=/dev/sda rw console=ttyS0,115200 ignore_loglevel nokaslr \\             cxl_acpi.dyndbg=+fplm cxl_pci.dyndbg=+fplm cxl_core.dyndbg=+fplm \\             cxl_mem.dyndbg=+fplm cxl_pmem.dyndbg=+fplm cxl_port.dyndbg=+fplm \\             cxl_region.dyndbg=+fplm cxl_test.dyndbg=+fplm cxl_mock.dyndbg=+fplm \\             cxl_mock_mem.dyndbg=+fplm dax.dyndbg=+fplm dax_cxl.dyndbg=+fplm \\             device_dax.dyndbg=+fplm&quot; \\    -smp 1 \\    -accel kvm \\    -serial mon:stdio \\    -nographic \\    -qmp tcp:localhost:4444,server,wait=off \\    -netdev user,id=network0,hostfwd=tcp::2024-:22 \\    -device e1000,netdev=network0 \\    -monitor telnet:127.0.0.1:12345,server,nowait \\    -drive file=$DISK_IMG,index=0,media=disk,format=raw \\    -machine q35,cxl=on -m 8G,maxmem=32G,slots=8 \\    -virtfs local,path=/lib/modules,mount_tag=modshare,security_model=mapped \\    -virtfs local,path=/home/zmy,mount_tag=homeshare,security_model=mapped #替换用户名为你设置的用户名  \\    -device pxb-cxl,bus_nr=12,bus=pcie.0,id=cxl.1 \\    -device cxl-rp,port=13,bus=cxl.1,id=root_port13,chassis=0,slot=2 \\    -object memory-backend-file,id=dhmem0,share=on,mem-path=/tmp/dhmem0.raw,size=4G \\    -object memory-backend-file,id=lsa0,share=on,mem-path=/tmp/lsa0.raw,size=512M \\    -device cxl-type3,bus=root_port13,volatile-dc-memdev=dhmem0,num-dc-regions=2,id=cxl-memdev0 \\    -M cxl-fmw.0.targets.0=cxl.1,cxl-fmw.0.size=4G,cxl-fmw.0.interleave-granularity=8K\n\n启动虚拟机网络:\nip link set dev enp0s2 updhclient enp0s2\n\n查询CXL设备:\napt install pciutilslspcilspci | grep CXLlspci -vvvlspci -vvv -s 0d:00.0\n\n小结按照上述流程,可以成功编译QEMU和Kernel,并使用虚拟机模拟CXL设备,美中不足的是参考文献的作者使用的是2.X的CXL设备,如何启动3.X的设备之后再探索\n参考文献\nCXL-Emulator-QEMU\n\n","categories":["Linux Kernel"],"tags":["QEMU","CXL","Linux Kernel"]},{"title":"QEMU ENABLE CXL 3.0","url":"/2026/02/04/QEMU-ENABLE-CXL-3-0/","content":"虚拟机配置使用Host Bridge直连: 2路相连,每路两个CXL设备拓扑图如下:\nHost ├── CXL Host Bridge (HB0) │     ├── Root Port 0 → Type3 Device 0 │     └── Root Port 1 → Type3 Device 1 └── CXL Host Bridge (HB1)       ├── Root Port 2 → Type3 Device 2       └── Root Port 3 → Type3 Device 3\n启动脚本如下:\nQEMU_BIN=&quot;$HOME/tool/qemu/build/qemu-system-x86_64&quot;KERNEL_IMG=&quot;$HOME/work/mempool/linux/arch/x86_64/boot/bzImage&quot;DISK_IMG=&quot;$HOME/tool/qemu/qemu-cxl-img&quot;$QEMU_BIN \\    -s \\    -kernel $KERNEL_IMG \\    -append &quot;root=/dev/sda rw console=ttyS0,115200 ignore_loglevel nokaslr \\             cxl_acpi.dyndbg=+fplm cxl_pci.dyndbg=+fplm cxl_core.dyndbg=+fplm \\             cxl_mem.dyndbg=+fplm cxl_pmem.dyndbg=+fplm cxl_port.dyndbg=+fplm \\             cxl_region.dyndbg=+fplm cxl_test.dyndbg=+fplm cxl_mock.dyndbg=+fplm \\             cxl_mock_mem.dyndbg=+fplm dax.dyndbg=+fplm dax_cxl.dyndbg=+fplm \\             device_dax.dyndbg=+fplm&quot; \\    -smp 1 \\    -accel kvm \\    -serial mon:stdio \\    -nographic \\    -qmp tcp:localhost:4444,server,wait=off \\    -netdev user,id=network0,hostfwd=tcp::2024-:22 \\    -device e1000,netdev=network0 \\    -monitor telnet:127.0.0.1:12345,server,nowait \\    -drive file=$DISK_IMG,index=0,media=disk,format=raw \\    -machine q35,cxl=on -m 8G,maxmem=32G,slots=8 \\    -virtfs local,path=/lib/modules,mount_tag=modshare,security_model=mapped \\    -virtfs local,path=/home/zmy,mount_tag=homeshare,security_model=mapped # 替换用户目录为你的目录\\     -object memory-backend-file,id=cxl-mem1,share=on,mem-path=/tmp/cxltest.raw,size=256M \\    -object memory-backend-file,id=cxl-mem2,share=on,mem-path=/tmp/cxltest2.raw,size=256M \\    -object memory-backend-file,id=cxl-mem3,share=on,mem-path=/tmp/cxltest3.raw,size=256M \\    -object memory-backend-file,id=cxl-mem4,share=on,mem-path=/tmp/cxltest4.raw,size=256M \\    -object memory-backend-file,id=cxl-lsa1,share=on,mem-path=/tmp/lsa.raw,size=256M \\    -object memory-backend-file,id=cxl-lsa2,share=on,mem-path=/tmp/lsa2.raw,size=256M \\    -object memory-backend-file,id=cxl-lsa3,share=on,mem-path=/tmp/lsa3.raw,size=256M \\    -object memory-backend-file,id=cxl-lsa4,share=on,mem-path=/tmp/lsa4.raw,size=256M \\    -device pxb-cxl,bus_nr=12,bus=pcie.0,id=cxl.1 \\    -device pxb-cxl,bus_nr=222,bus=pcie.0,id=cxl.2 \\    -device cxl-rp,port=0,bus=cxl.1,id=root_port13,chassis=0,slot=2 \\    -device cxl-type3,bus=root_port13,persistent-memdev=cxl-mem1,lsa=cxl-lsa1,id=cxl-pmem0,sn=0x1 \\    -device cxl-rp,port=1,bus=cxl.1,id=root_port14,chassis=0,slot=3 \\    -device cxl-type3,bus=root_port14,persistent-memdev=cxl-mem2,lsa=cxl-lsa2,id=cxl-pmem1,sn=0x2 \\    -device cxl-rp,port=0,bus=cxl.2,id=root_port15,chassis=0,slot=5 \\    -device cxl-type3,bus=root_port15,persistent-memdev=cxl-mem3,lsa=cxl-lsa3,id=cxl-pmem2,sn=0x3 \\    -device cxl-rp,port=1,bus=cxl.2,id=root_port16,chassis=0,slot=6 \\    -device cxl-type3,bus=root_port16,persistent-memdev=cxl-mem4,lsa=cxl-lsa4,id=cxl-pmem3,sn=0x4 \\    -M cxl-fmw.0.targets.0=cxl.1,cxl-fmw.0.targets.1=cxl.2,cxl-fmw.0.size=4G,cxl-fmw.0.interleave-granularity=8k\n\n使用交换机相连: 2路相连,每路两个CXL设备;延迟较第一种方法略高拓扑图如下:\nHost └── CXL Host Bridge       └── Root Port             └── CXL Switch (Upstream Port)                   ├── Downstream Port 0 → Type3 Device 0                   ├── Downstream Port 1 → Type3 Device 1                   ├── Downstream Port 2 → Type3 Device 2                   └── Downstream Port 3 → Type3 Device 3\n启动脚本如下:\nQEMU_BIN=&quot;$HOME/tool/qemu/build/qemu-system-x86_64&quot;KERNEL_IMG=&quot;$HOME/work/mempool/linux/arch/x86_64/boot/bzImage&quot;DISK_IMG=&quot;$HOME/tool/qemu/qemu-cxl-img&quot;$QEMU_BIN \\    -s \\    -kernel $KERNEL_IMG \\    -append &quot;root=/dev/sda rw console=ttyS0,115200 ignore_loglevel nokaslr \\             cxl_acpi.dyndbg=+fplm cxl_pci.dyndbg=+fplm cxl_core.dyndbg=+fplm \\             cxl_mem.dyndbg=+fplm cxl_pmem.dyndbg=+fplm cxl_port.dyndbg=+fplm \\             cxl_region.dyndbg=+fplm cxl_test.dyndbg=+fplm cxl_mock.dyndbg=+fplm \\             cxl_mock_mem.dyndbg=+fplm dax.dyndbg=+fplm dax_cxl.dyndbg=+fplm \\             device_dax.dyndbg=+fplm&quot; \\    -smp 1 \\    -accel kvm \\    -serial mon:stdio \\    -nographic \\    -qmp tcp:localhost:4444,server,wait=off \\    -netdev user,id=network0,hostfwd=tcp::2024-:22 \\    -device e1000,netdev=network0 \\    -monitor telnet:127.0.0.1:12345,server,nowait \\    -drive file=$DISK_IMG,index=0,media=disk,format=raw \\    -machine q35,cxl=on -m 8G,maxmem=32G,slots=8 \\    -virtfs local,path=/lib/modules,mount_tag=modshare,security_model=mapped \\    -virtfs local,path=/home/zmy,mount_tag=homeshare,security_model=mapped # 替换用户名 \\    -object memory-backend-file,id=cxl-mem0,share=on,mem-path=/tmp/cxltest.raw,size=256M \\    -object memory-backend-file,id=cxl-mem1,share=on,mem-path=/tmp/cxltest1.raw,size=256M \\    -object memory-backend-file,id=cxl-mem2,share=on,mem-path=/tmp/cxltest2.raw,size=256M \\    -object memory-backend-file,id=cxl-mem3,share=on,mem-path=/tmp/cxltest3.raw,size=256M \\    -object memory-backend-file,id=cxl-lsa0,share=on,mem-path=/tmp/lsa0.raw,size=256M \\    -object memory-backend-file,id=cxl-lsa1,share=on,mem-path=/tmp/lsa1.raw,size=256M \\    -object memory-backend-file,id=cxl-lsa2,share=on,mem-path=/tmp/lsa2.raw,size=256M \\    -object memory-backend-file,id=cxl-lsa3,share=on,mem-path=/tmp/lsa3.raw,size=256M \\    -device pxb-cxl,bus_nr=12,bus=pcie.0,id=cxl.1 \\    -device cxl-rp,port=0,bus=cxl.1,id=root_port0,chassis=0,slot=0 \\    -device cxl-rp,port=1,bus=cxl.1,id=root_port1,chassis=0,slot=1 \\    -device cxl-upstream,bus=root_port0,id=us0 \\    -device cxl-downstream,port=0,bus=us0,id=swport0,chassis=0,slot=4 \\    -device cxl-type3,bus=swport0,persistent-memdev=cxl-mem0,lsa=cxl-lsa0,id=cxl-pmem0,sn=0x1 \\    -device cxl-downstream,port=1,bus=us0,id=swport1,chassis=0,slot=5 \\    -device cxl-type3,bus=swport1,persistent-memdev=cxl-mem1,lsa=cxl-lsa1,id=cxl-pmem1,sn=0x2 \\    -device cxl-downstream,port=2,bus=us0,id=swport2,chassis=0,slot=6 \\    -device cxl-type3,bus=swport2,persistent-memdev=cxl-mem2,lsa=cxl-lsa2,id=cxl-pmem2,sn=0x3 \\    -device cxl-downstream,port=3,bus=us0,id=swport3,chassis=0,slot=7 \\    -device cxl-type3,bus=swport3,persistent-memdev=cxl-mem3,lsa=cxl-lsa3,id=cxl-pmem3,sn=0x4 \\    -M cxl-fmw.0.targets.0=cxl.1,cxl-fmw.0.size=4G,cxl-fmw.0.interleave-granularity=4k\nndctl工具ndctl工具包包含cxl-cli,可以在用户态进行CXL的配置管理和监控\n\n从官方源安装使用命令sudo apt install ndctl可以安装,但是ubuntu22.04支持的ndctl版本为v72,只能简单的列出设备内存信息,对于CXL3.0支持差,只有list,version,help,monitor,read &amp; write label六个命令\nsudo apt install ndctlcxl --version# 72.1+cxl list -Mu # 只有容量信息,region信息,命名空间等都不支持&#123;    &quot;memdev&quot;:&quot;mem0&quot;,    &quot;pmem_size&quot;:&quot;256.00 MiB (268.44 MB)&quot;,    &quot;ram_size&quot;:0&#125;\n从源码编译安装经测试最新版本V83-V80无法编译(CXL接口在Linux 6.11之后的版本有变更),需要降级支持CXL3.X的最低版本77编译安装后无法使用,会报错\nroot@s53:~/ndctl/build# cxlcxl: /lib/x86_64-linux-gnu/libcxl.so.1: version `LIBCXL_5&#x27; not found (required by cxl)cxl: /lib/x86_64-linux-gnu/libcxl.so.1: version `LIBCXL_6&#x27; not found (required by cxl)cxl: /lib/x86_64-linux-gnu/libcxl.so.1: version `LIBCXL_4&#x27; not found (required by cxl)cxl: /lib/x86_64-linux-gnu/libcxl.so.1: version `LIBCXL_3&#x27; not found (required by cxl)cxl: /lib/x86_64-linux-gnu/libcxl.so.1: version `LIBCXL_2&#x27; not found (required by cxl)\n折腾了一段时间,决定放弃,直接升级ubuntu24.04,官方源就支持v77了;sudo umount mntdir后重新配置磁盘信息,安装nobel版本ubuntu即可。\n使用ndctlndctl支持如下命令:\ncxl --list-cmdsversionlisthelpzero-labelsread-labelswrite-labelsdisable-memdevenable-memdevreserve-dpafree-dpadisable-portenable-portset-partitiondisable-buscreate-regionenable-regiondisable-regiondestroy-regionmonitor\n目前只使用list命令查看信息,create-region命令创建区域,其他命令暂时没有用到区域的四种模式:raw: 块设备访问,兼容传统存储栈fsdax(default): 字节可寻址访问,支持DAX文件系统(ext4&#x2F;xfs)devdax: 创建字符设备,程序通过mmap系统调用直接访问内存(阿里的数据库Paper就是这样干的)sector: 扇区对齐的块设备使用ndctl create-region -m mod &lt;bus-id&gt;创建后,对应的cxl-mem就会成为&#x2F;dev&#x2F;下的设备,用户可以通过mmap调用映射到用户空间使用。\n参考资料\nQEMu官方文档\n\n","categories":["Linux Kernel"],"tags":["QEMU","CXL","Linux Kernel"]},{"title":"序章","url":"/2026/01/29/%E5%BA%8F%E7%AB%A0/","content":"人生的前二十年我对做笔记不屑一顾,大三接连打了DB&amp;OceanBase比赛,赛后很久又需要用到数据库底层知识,才发现基础知识与细节忘得差不多,面对密密麻麻的收藏夹和链接感到手足无措,此后才开始逐步探索建立个人知识体系。笔记确实是必要的,人脑也可类比计算机,内存是稀少的,只能存少量近期热数据,磁盘容量也不大,更多的是建立知识索引,知道有什么,是什么,在哪里,笔记就是知识和体验的载体。看了很多代码,看了很多Paper,读了很多文章,不进行推理输出,这些参数终究没办法被持久化,只会是进进出出一无所获。在这清净的一方天地,写一些技术文章,代码剖析,论文解读,读书笔记,以及一些些思考,仅此而已。\n","categories":["杂谈"]}]